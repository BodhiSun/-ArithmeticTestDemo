package com.bodhi.arithmetictestdemo.practice;

/**
 * @author : Sun
 * @version : 1.0
 * create time : 2019/7/23 11:29
 * desc :认识哈希函数和哈希表
 *
 * 哈希函数(散列函数)具有以下性质:
 * 1.经典的哈希函数它的输入域是无穷大的
 * 2.哈希函数的输出域S是有穷尽的(即使 2^64依然是固定的 有范围的)
 * 3.当输入参数固定的情况下 得到的哈希函数的返回值一定是固定的 (哈希函数不是随机函数 样本一样的情况下 返回值一定一样)
 * 4.当输入参数不一样也有可能得到相同的返回值。即哈希碰撞(两个样本碰撞了得到的hashcode是一个)
 * 5.虽然会有两个不同的输入对应一个相同输出，如果有大量不同输入的情况下，将会在整个S域上均匀的出现他们返回值，即哈希函数的离散性
 *  eg:假如给定输入域为0~98共99个不同的数 输出域为0,1,2  依次计算每个值对应的输出 基本上0,1,2三个数上各有33个数分布，S域上均匀分布
 *
 * 哈希函数特征：
 * 1.哈希函数返回值和输入的规律没有关系 否则就不能均匀分布了
 * 2.每一个input经过hash函数得到的返回值code ，如果在整个S域上均匀分布，把每一个返回值 %m 则在新的0~m-1域上也会均匀分布
 *
 *
 * 哈希表经典结构：系统先分配一个固定大小比如0~16的地址 存放增进来的数据，当通过put/add 添加数据时 key值根据hash函数算出一个返回值
 * 然后返回值%17 得出来的值就是在分配地址中对应的位置 类似于把k,v作为一个节点放在对应位置上 因为会出现哈希碰撞所以不同key可能最终算
 * 出来的位置是相同的 ，此时后面的数据 直解链在前一个节点后面 每一个位置形成一个链表结构 当链表达到一定长度 影响数据存取效率时 哈希
 * 表会进行一次扩容 比如从0~16 扩大到0~32 然后重新把先前地址上的数据 重新计算哈希值 然后分配到新的扩容后的地址上。
 *
 * 在jvm中哈希表的每个位置不是链表结构 是红黑树(平衡搜索二叉树)结构 所以在jvm种哈希表很少经过扩容
 *
 * 哈希表的增删改查时间复杂度默认为是O(1)
 *
 *
 */
public class HashPractice_HashFunctionHashTable {
}
