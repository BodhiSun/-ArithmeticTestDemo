package com.bodhi.seniorcourse;

/**
 * @author : Sun
 * @version : 1.0
 * create time : 2019/8/9 16:48
 * desc :BFPRT算法-在一个无序数组中找到第K小的数或第K大的数
 * 时间复杂度O(n)
 *
 * 思路一：先排序然后直接取 O(N*logN)
 *
 * 思路二：荷兰国旗问题的改进法 随机取一个数划分三个区域 patition过程中判断等于区域是否命中待求值 命中直接返回 否则在
 * 左边或者右边在进行partition过程依次递归下去 时间复杂度长期期望(概率期望)是O(n)
 *
 * 思路三：BFPRT算法：
 * 第一步：将整个数组划分成每5个一组 一共 n/5组 O(1)
 * 第二步: 将每个组内单独排序 组与组之间不管 O(n)
 * 第三步：求每个组的中位数 然后组成一个长度为n/5的新数组 O(n)
 * 第四步：将中位数组成的新数组递归调用上述步骤 求出中位数 T(n/5)
 * 第五步：将原数组按照求解出来的中位数值划分 小于 等于 大于 三个区域 O(n)
 * 第六步: 如果等于区域没命中 继续将左边或者将右边(最多(7/10)n个数)继续划分 T(7/10)n)
 * 整个事件复杂度T(N)=T(N/5)+T((7/10)N)+O(N) =O(N)(不符合master公式但是数学已经证明了收敛于O(N),按3,5,7个数分组都可以)
 *
 *
 */
public class BFPRT_Arithmetic {
}
